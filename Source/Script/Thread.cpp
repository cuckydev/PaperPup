#include "Script/Thread.h"

#include <memory>
#include <iostream>

#include "Types/Exceptions.h"

#include "Luau/Compiler.h"

namespace PaperPup::Leon
{

// Generated by Leon to ${CMAKE_BINARY_DIR}/LeonProject/glue.cpp
void Register(lua_State *L);

}

namespace PaperPup::Script
{

namespace detail
{

// Lua singleton state
static SingletonState NewSingletonState()
{
	// Create new state
	SingletonState state(luaL_newstate(), lua_close);
	if (state == nullptr)
		throw Types::RuntimeException("Failed to create Luau singleton state");

	// Load built-in libraries
	// Luau doesn't include any libraries that give access to the host system
	// so no need to uninstall those
	luaL_openlibs(state.get());

	// Register libraries
	Leon::Register(state.get());

	// Sandbox state
	// This makes all the globals we just loaded read-only
	luaL_sandbox(state.get());

	return state;
}

lua_State &Singleton()
{
	static SingletonState singleton(NewSingletonState());
	return *(singleton.get());
}

lua_State &NewThread()
{
	lua_State &singleton = detail::Singleton();

	// Create new thread
	lua_State *state = lua_newthread(&singleton);
	if (state == nullptr)
		throw Types::RuntimeException("Failed to create new Luau thread");

	lua_pop(&singleton, 1);

	// Sandbox thread
	// This replaces the global table one that can't modify the singleton globals
	luaL_sandboxthread(state);

	return *state;
}

}

// Thread constructor
Thread::Thread()
{
	lua_State &state = detail::NewThread();
	ref.reset(new ThreadRef(state, *this));
}

Thread::Thread(const std::string &name, const std::string &source) : Thread()
{
	// Compile script to bytecode and load it
	static Luau::CompileOptions copt;
	copt.optimizationLevel = 2;
	copt.debugLevel = 1; // Keep enough debug info for backtraces

	std::string bytecode = Luau::compile(source, copt);

	lua_State &state = ref->GetState();
	int result = luau_load(&state, name.c_str(), bytecode.data(), bytecode.size(), 0);
	if (result != LUA_OK)
		throw Types::RuntimeException(lua_tostring(&state, -1));
}

Thread::~Thread()
{
	if (ref != nullptr)
		ref->Release();
}

void Thread::Resume()
{
	Log::Assert(!IsDead(), "Cannot use dead thread");

	lua_State &singleton = detail::Singleton();

	// Resume thread and handle errors
	lua_State &state = ref->GetState();
	int result = lua_resume(&state, &singleton, 0);

	switch (result)
	{
		case LUA_OK:
		case LUA_YIELD:
			break;
		case LUA_ERRRUN:
			throw Types::RuntimeException(lua_tostring(&state, -1));
			break;
		case LUA_ERRMEM:
			throw Types::RuntimeException("Memory allocation error");
			break;
		case LUA_ERRERR:
			throw Types::RuntimeException("Error in message handler");
			break;
		case LUA_BREAK:
			throw Types::RuntimeException("Unhandled breakpoint");
			break;
		default:
			throw Types::RuntimeException("Unknown error");
			break;
	}
}

// Thread reference and registration
// We need to be able to get the C++ Thread class from the Lua thread state
// but also have light references to the Lua thread state with their own
// lifetime, and ensuring the Lua thread state is not garbage collected
ThreadRef::ThreadRef(lua_State &state, Thread &thread)
{
	lua_State &singleton = detail::Singleton();

	thread_state = &state;

	lua_pushthread(thread_state);
	lua_xmove(thread_state, &singleton, 1);
	thread_ref = lua_ref(&singleton, -1);
	lua_pop(&singleton, 1);

	lua_setthreaddata(thread_state, &thread);
}

ThreadRef::~ThreadRef()
{
	Release();

	lua_unref(&(detail::Singleton()), thread_ref);
}

void ThreadRef::Register(Thread &thread)
{
	lua_setthreaddata(thread_state, &thread);
}

void ThreadRef::Release()
{
	if (thread_state != nullptr)
		lua_setthreaddata(thread_state, nullptr);
}

Thread *Thread::GetThread(lua_State &L)
{
	Thread *thread = static_cast<Thread *>(lua_getthreaddata(&L));
	return thread;
}

}
