#include "Script/Thread.h"

#include <memory>
#include <iostream>

#include "Types/Exceptions.h"

#include "Luau/Compiler.h"

namespace PaperPup::Leon
{

// Generated by Leon to ${CMAKE_BINARY_DIR}/LeonProject/glue.cpp
void Register(lua_State *L);

}

namespace PaperPup::Script
{

namespace detail
{

// Lua singleton state
static SingletonState NewSingletonState()
{
	// Create new state
	SingletonState state(luaL_newstate(), lua_close);
	if (state == nullptr)
		throw Types::RuntimeException("Failed to create Luau singleton state");

	// Load libraries
	luaL_openlibs(state.get());

	// Register libraries
	Leon::Register(state.get());

	// Sandbox state
	luaL_sandbox(state.get());
	return state;
}

lua_State *Singleton()
{
	static SingletonState singleton(NewSingletonState());
	return singleton.get();
}

lua_State *NewThread()
{
	lua_State *singleton = detail::Singleton();

	// Create new thread
	lua_State *state = lua_newthread(singleton);
	if (state == nullptr)
		luaL_error(singleton, "Failed to create new Luau thread");

	lua_pop(singleton, 1);

	// Sandbox thread
	luaL_sandboxthread(state);

	return state;
}

}

// Thread constructor
Thread::Thread()
{
	lua_State *singleton = detail::Singleton();

	lua_State *state = detail::NewThread();
	ref.reset(new ThreadRef(state, *this));
}

Thread::Thread(const std::string &source) : Thread()
{
	lua_State *singleton = detail::Singleton();
	
	// Compile script to bytecode and load it
	static Luau::CompileOptions copt;
	copt.optimizationLevel = 2;
	copt.debugLevel = 1; // Keep enough debug info for backtraces

	std::string bytecode = Luau::compile(source, copt);

	lua_State *state = ref->GetState();
	int result = luau_load(state, "Thread", bytecode.data(), bytecode.size(), 0);
	if (result != LUA_OK)
		luaL_error(singleton, lua_tostring(state, -1));
}

Thread::~Thread()
{
	ref->Release();
}

void Thread::Resume()
{
	lua_State *singleton = detail::Singleton();

	// Resume thread and handle errors
	lua_State *state = ref->GetState();
	int result = lua_resume(state, singleton, 0);

	switch (result)
	{
		case LUA_OK:
		case LUA_YIELD:
			break;
		case LUA_ERRRUN:
			luaL_error(singleton, lua_tostring(state, -1));
			break;
		case LUA_ERRMEM:
			luaL_error(singleton, "Memory allocation error");
			break;
		case LUA_ERRERR:
			luaL_error(singleton, "Error in message handler");
			break;
		case LUA_BREAK:
			luaL_error(singleton, "Unhandled breakpoint");
			break;
		default:
			luaL_error(singleton, "Unknown error");
			break;
	}
}

ThreadRef::ThreadRef(lua_State *state, Thread &thread)
{
	lua_State *singleton = detail::Singleton();

	thread_state = state;

	lua_pushthread(thread_state);
	lua_xmove(thread_state, singleton, 1);
	thread_ref = lua_ref(singleton, -1);
	lua_pop(singleton, 1);

	lua_setthreaddata(thread_state, &thread);
}

ThreadRef::~ThreadRef()
{
	Release();

	lua_unref(detail::Singleton(), thread_ref);
}

void ThreadRef::Register(Thread &thread)
{
	lua_setthreaddata(thread_state, &thread);
}

void ThreadRef::Release()
{
	if (thread_state != nullptr)
		lua_setthreaddata(thread_state, nullptr);
}

Thread *Thread::GetThread(lua_State *L)
{
	Thread *thread = static_cast<Thread *>(lua_getthreaddata(L));
	return thread;
}

}
